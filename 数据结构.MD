# 数据结构
![](https://pic2.zhimg.com/80/v2-d3ff88ce8432ccee1e1a6456eddd7051_720w.jpg)
# 常见的数据结构
1. 栈（Stack）：栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。 
   
2. 队列（Queue）：队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。
3. 数组（Array）：数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。
4. 链表（Linked List）：链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。
5. 树（Tree）：树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。
6. 图（Graph）：图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。
7. 堆（Heap）：堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。
8. 散列表（Hash table）：散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。
# 常用算法
1. 检索：检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段值的节点。
   
2. 插入：往数据结构中增加新的节点。
3. 删除：把指定的结点从数据结构中去掉。
4. 更新：改变指定节点的一个或多个字段的值。
5. 排序：把节点按某种指定的顺序重新排列。例如递增或递减。
# 逻辑结构
1. 线性结构：数据元素之间存在一对一的关系
   
2. 树形结构：数据元素之间存在一对多的关系
3. 图形结构：数据元素之间存在多对多的关系
4. 集合结构：数据元素属于同一个集合
![](https://pic2.zhimg.com/80/v2-2575aa37a54fbf5c8ede82e28c0282e1_720w.jpg)
# 存储结构
1. 顺序存储：逻辑上相邻的元素存储在物理位置相邻的存储单元中
2. 链式存储：在数据元素中添加一些地址域或者辅助结构，用于存放数据元素之间的关系
![](https://pic2.zhimg.com/80/v2-5824a5b8a5505e0c4daa0f9955ef8169_720w.jpg)
# 算法
- 输入：有零个或多个输入量
- 输出：产生至少一个输出量
- 确定性：算法的指令清晰，无歧义
- 有限性：算法的指令执行次数有限，执行时间有限
![](https://pic1.zhimg.com/80/v2-8fd0e2b9f83cb9891f6d47822cc72aa4_720w.jpg)
## 计算机解决生产问题的过程可以分为下面五个步骤:
1. 问题的理解：搞清楚问题的输入、要求和输出
2. 数据结构设计：设计能处理问题中数据的数据结构，还要设计能支持算法策略的数据结构
3. 算法设计：选择算法策略，用适当的方式描述和逐步细化算法步骤
4. 算法分析：发现有优化的地方，返回第二步，重新设计数据结构和算法
5. 程序实现：用计算机编程，定义数据结构，编写代码实现，并调试和运行
![](https://mmbiz.qpic.cn/mmbiz_png/iaJPvricOSmTfleH8vSWnQNquI3O27EANfXaib2JvVnEZkG1Xh62ju8C8EQctiaT4FDdWibqiabFaukj6qJmYRhVn4ibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
# 时间复杂度
 编程实现算法后，算法就是由一组语句构成，算法的执行效率就由各语句执行的次数所决定。一个算法花费的时间与算法中语句的执行次数成正比，哪个算法语句执行词次数多，它花费的时间就越多，把时间复杂度为T(n)，一般情况下，算法的基本操作重复执行的次数是关于模块 n 的一个函数f(n), 因此，我们可以把算法的时间复杂度记做：T(n)=O(f(n))
# 求绝对值
我们需要一个整数的绝对值，在算法设计上，只需要输入的值为负数时，返回它的相反数，其他情况返回本身，代码如下：
```c
public static int abs(int a){
    return a < 0 ? -a : a;
}
```
该代码中只有一条运算指令语句，时间复杂度为O(1)
# 数组求和
已知一个整型数组，需要对数组内所有元素求和，如果只是通过遍历所有元素而不使用其他方法进行求和，可以使用如下代码实现：
```c
public static int sum(int[] a){
    int s = 0;
    for (int i : a){
        s +=i;
    }
    return s;
}
```
由代码可知，如果输入数组的大小为n，执行语句中初始化赋值需要时间O(1)，循环语句中的赋值操作需要时间为O(1)*n，所以语句执行的时间为：O(1)+O(1)*N=O(N+1)=O(N)
# 二分查找
已知一个有序数组，需要在数组中找到某个元素的位置，我们可以通过二分法来实现，代码如下：
```c
public static int binarysearch(int[] a,int b){
    int i, r=0, l=a.length;
    while(r <= 1){
        i = (r + 1) / 2;
        if(a[i]<b){
            r = i + 1;
        }else if (a[i] > b){
            l = i - 1;
        }else{
            return i;
        } 
    }
    return -1;
}
```
